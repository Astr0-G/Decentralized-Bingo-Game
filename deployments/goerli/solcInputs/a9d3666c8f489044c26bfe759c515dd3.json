{
  "language": "Solidity",
  "sources": {
    "contracts/BasicBingoGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.8;\r\n\r\n/// @title Bingo Game Smart Contract\r\n/// @author astro Ge\r\n/// @notice You can use this contract for playing bingo game\r\n\r\nimport \"./Interface/ICER20.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\nerror erorr__entryFee();\r\nerror error__inGameAlready();\r\nerror error__drawsNotStared();\r\nerror error__winnerIsDRAWING();\r\nerror error__gameStarted();\r\nerror error__notInGameOrClaimedRewards();\r\nerror error__notAdmin();\r\nerror error__exceedLimitPlayersInOneGame();\r\n\r\ncontract BingoBasic {\r\n    /// @notice This is game stage for each player in each game round\r\n    enum gameStage {\r\n        BETTING,\r\n        DRAWING,\r\n        DARWED\r\n    }\r\n\r\n    /// @notice This is player struct in each game round\r\n    struct player {\r\n        gameStage stage;\r\n        uint256[25] gameBoard;\r\n        /// @notice Matched number will be set as 1 for function to know it matches, 0 means unmatch\r\n        mapping(uint256 => uint256) gameBoardMatchs;\r\n    }\r\n\r\n    struct gameRound {\r\n        /// @notice When one person calls function `drawWinnerOrClaimRewrads`, it will draw the winner of this round\r\n        bool drawing;\r\n        /// @notice If `winnerAnnounced` is true, other players don't have to draw instead of claiming their prize\r\n        bool winnerAnnounced;\r\n        uint256 startTime;\r\n        uint256 bingo;\r\n        /// @notice Support multiple players in a game\r\n        /// @notice If two or more players have their first bingo in the same round, they will share the prize pool\r\n        address[] winner;\r\n        address[] playersArray;\r\n        uint256[24] winningNumders;\r\n        mapping(address => player) players;\r\n    }\r\n\r\n    uint256 public gameRoundNow;\r\n    /// @notice Admin can update the entry fee, join duration, and turn duration\r\n    address public admin;\r\n    /// @notice Games have a minimum join duration before start\r\n    /// @notice `joinDuration` sets to 180 seconds as default to save gas\r\n    uint256 public joinDuration = 180;\r\n    /// @notice Games have a minimum turn duration between draws\r\n    /// @notice `turnDuration` sets to 180 seconds as default to save gas\r\n    uint256 public turnDuration = 180;\r\n    /// @notice Each player pays an ERC20 entry fee, transferred on join\r\n    address public BingoToken;\r\n    /// @notice `betAmountForBINGO` sets to 1 token as default to save gas\r\n    uint256 public betAmountForBINGO = 1000000000000000000;\r\n    /// @notice returnBet sets the contract whether return player entry fee or not, default as `true` for basic bingo game\r\n    bool public returnBet = true;\r\n    /// @notice maxPlayerNum sets the max player numbers in a game, default as 4 due to out of gas problem\r\n    uint256 public maxPlayerNum = 4;\r\n\r\n    /// @notice Support multiple concurrent games\r\n    mapping(uint256 => gameRound) gameRounds;\r\n\r\n    /// @notice Event emit when player create a new game\r\n    event Created(\r\n        address indexed creator,\r\n        uint256 indexed roundCreated,\r\n        uint256 indexed timeCreated\r\n    );\r\n    /// @notice Event emit when player joins a existing game\r\n    event Joined(address indexed player, uint256 indexed roundJoined);\r\n    /// @notice Event emit when a game is drawed\r\n    /// @dev bingoRound == 0: no Bingo; bingoRound > 0: bingo in number of rounds\r\n    event Drawed(\r\n        uint256 indexed gameRound,\r\n        uint256 indexed playersNum,\r\n        uint256[24] winningNumbers,\r\n        uint256 bingoRound\r\n    );\r\n    /// @notice Event emit when a player claimed prize\r\n    event Claimed(address indexed player, uint256 indexed Claimed);\r\n\r\n    /// @notice Only allowing one player to draw the winning numbers with time limit\r\n    modifier drawingWinnerCheck(uint256 _gameRound) {\r\n        if (block.timestamp < gameRounds[_gameRound].startTime + joinDuration + turnDuration)\r\n            revert error__drawsNotStared();\r\n        if (gameRounds[_gameRound].drawing) revert error__winnerIsDRAWING();\r\n\r\n        /// @notice Start drawing\r\n        gameRounds[_gameRound].drawing = true;\r\n        _;\r\n        /// @notice Stop drawing\r\n        gameRounds[_gameRound].drawing = false;\r\n    }\r\n\r\n    /// @notice Deploying Bingo Token first before deploying this contract\r\n    constructor(address _bingoTokenAddress) {\r\n        BingoToken = _bingoTokenAddress;\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /// @notice player start a new with game board generated\r\n    function startNewGameWithBet() public {\r\n        /// @notice Send Bingo Token to this contract, and check transaction success\r\n        if (IERC20(BingoToken).transferFrom(msg.sender, address(this), betAmountForBINGO) != true)\r\n            revert erorr__entryFee();\r\n        /// @notice Make a new game round\r\n        unchecked {\r\n            ++gameRoundNow;\r\n        }\r\n        /// @notice Save game round Id into this function\r\n        uint256 gameRoundnow = gameRoundNow;\r\n        /// @notice Save game round start time\r\n        gameRounds[gameRoundnow].startTime = block.timestamp;\r\n        /// @notice Generating player game board for this game round\r\n        playerGenerateGameBoard(msg.sender, gameRoundnow);\r\n        emit Created(msg.sender, gameRoundnow, block.timestamp);\r\n    }\r\n\r\n    /// @notice Players join current game and generate their game board\r\n    /// @param _gameRoundToJoin the round of game id\r\n    /// @dev Worst case of nobody has a bingo for 4 players are about 24356551 gas within 0 - 64 as numbers that this contract generated for bingo game with 24 winning numbers generated\r\n    function joinCurrentGameWithBet(uint256 _gameRoundToJoin) public {\r\n        /// @notice With 2 lines above being said, limit no more than 4 players in a game to limit out of gas problem\r\n        if (gameRounds[_gameRoundToJoin].playersArray.length + 1 > maxPlayerNum)\r\n            revert error__exceedLimitPlayersInOneGame();\r\n        (gameStage stageOfPlayer, uint256 roundStartedTimeWithDuration) = getRoundDetails(\r\n            _gameRoundToJoin,\r\n            msg.sender\r\n        );\r\n        /// @notice Player can join multiple game at the same time, but not in the same round\r\n        if (stageOfPlayer != gameStage.BETTING) revert error__inGameAlready();\r\n        /// @notice Players can not join the game after join duration\r\n        if (block.timestamp > roundStartedTimeWithDuration) revert error__gameStarted();\r\n        /// @notice Send Bingo Token to this contract, and check transaction success\r\n        if (IERC20(BingoToken).transferFrom(msg.sender, address(this), betAmountForBINGO) != true)\r\n            revert erorr__entryFee();\r\n        /// @notice Generating player game board for this game round\r\n        playerGenerateGameBoard(msg.sender, _gameRoundToJoin);\r\n    }\r\n\r\n    /// @notice Players draw winner of this game round or claim prize\r\n    /// @dev if one game is drawed, other players in this round\r\n    /// @param _gameRound the round of game id that player joined\r\n    function drawWinnerOrClaimPrize(uint256 _gameRound) public drawingWinnerCheck(_gameRound) {\r\n        /// @notice Cheak if stage of player in this is DRAWING to let them draw or claim\r\n        if (gameRounds[_gameRound].players[msg.sender].stage != gameStage.DRAWING)\r\n            revert error__notInGameOrClaimedRewards();\r\n        /// @notice Read bet amount to use for this function at beginning to save gas\r\n        uint256 betAmount = betAmountForBINGO;\r\n        uint256 prizeToSend;\r\n        /// @notice If winner is announced then distribute the prize to the caller\r\n        /// @dev This only be true when second time this function is called\r\n        if (gameRounds[_gameRound].winnerAnnounced == true) {\r\n            /// @notice If there is one of more bingo achieved, check the prize and send to the winner\r\n            if (gameRounds[_gameRound].bingo > 0) {\r\n                prizeToSend = checkPrize(_gameRound, msg.sender);\r\n                if (prizeToSend > 0) {\r\n                    IERC20(BingoToken).transfer(msg.sender, prizeToSend);\r\n                }\r\n            } else {\r\n                /// @notice If there no bingo achieved, refund Bingo Token player bet\r\n                IERC20(BingoToken).transfer(msg.sender, betAmount);\r\n            }\r\n        } else {\r\n            /// @notice Draw winner or winners, if two players achieved bingo in the same round, they will split the prize poll\r\n            /// @dev Drawing winner spend unbelievable gas amount, using a automation keeper to call this function could wave gas for player in real cases\r\n            /// @notice Read players's addresses to use for this function at beginning of drawing process to save gas\r\n            address[] memory playersArrays = gameRounds[_gameRound].playersArray;\r\n            /// @notice if there are more than one player in the game, then drawing start\r\n            if (playersArrays.length > 1) {\r\n                /// @notice Call `gameGenerateNumber` to generate winning numbers\r\n                /// @dev Will generate 24 winning numbers for players for full experience of Bingo game\r\n                uint256[24] memory winningNumbers = gameGenerateNumber(_gameRound);\r\n                uint256 BingoIndex = 24;\r\n                /// @notice i: i is representing players index in this game round, loop from first player to the last player\r\n                /// @notice j: j is representing players first bingo index in this game round\r\n                /// @dev j: if there is a first bingo in any players game board, we set j + 1 for the loop limit to save gas\r\n                /// @notice k: k is representing players game board number index, loop from 0 - 24\r\n                uint256 i;\r\n                uint256 j;\r\n                uint256 k;\r\n                do {\r\n                    j = 0;\r\n                    do {\r\n                        k = 0;\r\n                        uint256[25] memory playerGameBoard = getPlayerGameBoard(\r\n                            playersArrays[i],\r\n                            _gameRound\r\n                        );\r\n                        do {\r\n                            /// @notice If winning number and one of the player game board matches, set the players game board matches mapping to be 1\r\n                            if (winningNumbers[j] == playerGameBoard[k]) {\r\n                                gameRounds[_gameRound].players[playersArrays[i]].gameBoardMatchs[\r\n                                        k\r\n                                    ] = 1;\r\n                            }\r\n                            /// @notice Skip center number\r\n                            if (k == 11) {\r\n                                unchecked {\r\n                                    ++k;\r\n                                }\r\n                            }\r\n                            unchecked {\r\n                                ++k;\r\n                            }\r\n                            /// @notice When checking more than 5 numbers, check if this is a bingo or not\r\n                            if (k > 4) {\r\n                                /// @notice If bingo is true\r\n                                if (checkWinning(_gameRound, playersArrays[i])) {\r\n                                    /// @notice set j to be bingo round + 1 to let other player check till this round to see if there are more than one winner in this game\r\n                                    if (j == BingoIndex - 1) {\r\n                                        gameRounds[_gameRound].winner.push(playersArrays[i]);\r\n                                    } else {\r\n                                        /// @notice If new bingo round is less than the first one, clean winner array and save this new winner\r\n                                        gameRounds[_gameRound].winner = new address[](0);\r\n                                        gameRounds[_gameRound].winner.push(playersArrays[i]);\r\n                                    }\r\n                                    unchecked {\r\n                                        BingoIndex = j + 1;\r\n                                    }\r\n                                    /// @notice Save bingo round number into contract\r\n                                    gameRounds[_gameRound].bingo = j;\r\n                                    console.log(\r\n                                        \"First Bingo in round\",\r\n                                        j,\r\n                                        \"for player address\",\r\n                                        playersArrays[i]\r\n                                    );\r\n                                    break;\r\n                                }\r\n                            }\r\n                        } while (k < 25);\r\n                        unchecked {\r\n                            ++j;\r\n                        }\r\n                    } while (j < BingoIndex);\r\n                    unchecked {\r\n                        ++i;\r\n                    }\r\n                } while (i < playersArrays.length);\r\n                gameRounds[_gameRound].winnerAnnounced = true;\r\n                if (gameRounds[_gameRound].bingo > 0) {\r\n                    prizeToSend = checkPrize(_gameRound, msg.sender);\r\n                    if (prizeToSend > 0) {\r\n                        IERC20(BingoToken).transfer(msg.sender, prizeToSend);\r\n                    }\r\n                } else if (gameRounds[_gameRound].playersArray.length <= 1 || returnBet) {\r\n                    /// @notice If there no bingo achieved, refund Bingo Token player bet\r\n                    IERC20(BingoToken).transfer(msg.sender, betAmount);\r\n                }\r\n                emit Drawed(\r\n                    _gameRound,\r\n                    playersArrays.length,\r\n                    winningNumbers,\r\n                    gameRounds[_gameRound].bingo\r\n                );\r\n            } else if (gameRounds[_gameRound].playersArray.length <= 1 || returnBet) {\r\n                /// @notice If there no bingo achieved, refund Bingo Token player bet\r\n                IERC20(BingoToken).transfer(msg.sender, betAmount);\r\n            }\r\n        }\r\n        gameRounds[_gameRound].players[msg.sender].stage = gameStage.DARWED;\r\n        emit Claimed(msg.sender, prizeToSend);\r\n    }\r\n\r\n    /// @notice Player generating game board when creating or joinning a game\r\n    /// @dev `joinCurrentGameWithBet` & `startNewGameWithBet` will call this internal function\r\n    /// @param _player player's address\r\n    /// @param _gameRound the round of game id\r\n    function playerGenerateGameBoard(address _player, uint256 _gameRound) internal {\r\n        /// @notice Change player's stage of this game round to DRAWING\r\n        gameRounds[_gameRound].players[_player].stage = gameStage.DRAWING;\r\n        /// @notice Save player's address to game round player array\r\n        gameRounds[_gameRound].playersArray.push(_player);\r\n        uint256 i;\r\n        /// @notice Make a memory array for generating game board numbers in this function\r\n        /// @dev Saving more gas compares to directly save numbers into contract each time\r\n        uint256[25] memory array;\r\n        /// @dev Generate random number, but could be replaced by on-chain services provider, such as Chainlink\r\n        bytes32 blockHashPrevious = blockhash(block.number - 1);\r\n        uint256 seed = uint256(blockHashPrevious);\r\n        uint256 randomNumber = uint256(keccak256(abi.encodePacked(seed, msg.sender)));\r\n        /// @dev Use do while and unchecked{} to save gas.\r\n        do {\r\n            /// @notice Check if the random number bigger than 64\r\n            /// @dev The reason why i choose 64 is because 256 will hardly get a bingo and spent a lot of gas without a winner\r\n            /// @dev We could definetly choose 256 if we insist\r\n            randomNumber = (randomNumber >> 6 > 0)\r\n                ? (randomNumber >> 6) % 64\r\n                : (uint256(keccak256(abi.encodePacked(seed, msg.sender, i)))) % 64;\r\n            /// @notice Save random number into memory array\r\n            array[i] = randomNumber;\r\n            /// @notice No need to save the center game borad number\r\n            if (i == 11) {\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        } while (i < 25);\r\n        /// @notice Save generated number into player game board\r\n        gameRounds[_gameRound].players[_player].gameBoard = array;\r\n        /// @notice Set player game board matches array[12] become matched\r\n        gameRounds[_gameRound].players[_player].gameBoardMatchs[12] = 1;\r\n        emit Joined(msg.sender, _gameRound);\r\n    }\r\n\r\n    /// @notice Game generating winning number of this game round\r\n    /// @dev `drawWinnerOrClaimPrize` will call this internal function\r\n    /// @param _gameRound the round of game id\r\n    function gameGenerateNumber(uint256 _gameRound) internal returns (uint256[24] memory) {\r\n        /// @notice Make a memory array for generating game board numbers in this function\r\n        /// @dev Saving more gas compares to directly save numbers into contract each time\r\n        /// @dev Choose 24 winning numbers between 0 - 63 is enough for a bingo to be true, and it is also be able to make player gameboard match all bingos\r\n        /// @dev Worst case of nobody has a bingo for five players are about 28000000 gas within 0 - 64 as numbers that this contract generated for bingo game with 24 winning numbers generated\r\n        /// @dev We could definetly choose more to make every game has a Bingo if we insist\r\n        uint256[24] memory array;\r\n        uint256 i;\r\n        /// @dev Generate random number, but could be replaced by on-chain services provider, such as Chainlink\r\n        bytes32 blockHashPrevious = blockhash(block.number - 1);\r\n        uint256 seed = uint256(blockHashPrevious);\r\n        uint256 randomNumber = uint256(keccak256(abi.encodePacked(seed, msg.sender)));\r\n        /// @dev Use do while and unchecked{} to save gas.\r\n        do {\r\n            /// @notice Check if the random number bigger than 64\r\n            /// @dev The reason why choose 64 is because 256 will hardly get a bingo and spent a lot of gas without a winner\r\n            /// @dev We could definetly choose 256 if we insist\r\n            randomNumber = (randomNumber >> 6 > 0)\r\n                ? (randomNumber >> 6) % 64\r\n                : (uint256(keccak256(abi.encodePacked(seed, msg.sender, i)))) % 64;\r\n            /// @notice Save random number into memory array\r\n            array[i] = randomNumber;\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        } while (i < 24);\r\n        /// @notice Save winning numbers into contract\r\n        gameRounds[_gameRound].winningNumders = array;\r\n        return (array);\r\n    }\r\n\r\n    /// @notice get player stage of this round and timestamp right after join duration ends\r\n    /// @dev `joinCurrentGameWithBet` will call this internal function\r\n    /// @param _gameRound the round of game id\r\n    /// @param _player player address of this round of game\r\n    function getRoundDetails(\r\n        uint256 _gameRound,\r\n        address _player\r\n    ) internal view returns (gameStage, uint256) {\r\n        return (\r\n            gameRounds[_gameRound].players[_player].stage,\r\n            gameRounds[_gameRound].startTime + joinDuration\r\n        );\r\n    }\r\n\r\n    /// @notice Get the Bingo result of this round of game and winning numbers\r\n    /// @param _gameRound the round of game id\r\n    function getRoundBingoResult(\r\n        uint256 _gameRound\r\n    ) public view returns (bool, uint256[24] memory) {\r\n        return (gameRounds[_gameRound].bingo > 0, gameRounds[_gameRound].winningNumders);\r\n    }\r\n\r\n    /// @notice Get player game board numbers in a uint256 array\r\n    /// @param _gameRound the round of game id\r\n    /// @param _player player address of this round of game\r\n    function getPlayerGameBoard(\r\n        address _player,\r\n        uint256 _gameRound\r\n    ) public view returns (uint256[25] memory) {\r\n        return (gameRounds[_gameRound].players[_player].gameBoard);\r\n    }\r\n\r\n    /// @notice Check prize for the player of this game round\r\n    /// @dev `drawWinnerOrClaimPrize` and `checkWinner` will call this internal function\r\n    /// @param _gameRound the round of game id\r\n    /// @param _player player address of this round of game\r\n    function checkPrize(\r\n        uint256 _gameRound,\r\n        address _player\r\n    ) internal view returns (uint256 winningPrize) {\r\n        address[] memory winnners = gameRounds[_gameRound].winner;\r\n        uint256 i;\r\n        uint256 n;\r\n        do {\r\n            if (winnners[i] == _player) {\r\n                unchecked {\r\n                    ++n;\r\n                }\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        } while (i < winnners.length);\r\n        /// @notice If there is more than one winnier, n will be equal to 1 and times betAmountForBINGO times numbers of players divided by winners number\r\n        return ((n * (betAmountForBINGO * (gameRounds[_gameRound].playersArray.length))) /\r\n            (winnners.length));\r\n    }\r\n\r\n    /// @notice Check if player is the the winner of this game round, and returns bool with winning prize to claim\r\n    /// @param _gameRound the round of game id\r\n    /// @param _player player address of this round of game\r\n    function checkWinner(uint256 _gameRound, address _player) public view returns (bool, uint256) {\r\n        address[] memory winnners = gameRounds[_gameRound].winner;\r\n        uint256 i;\r\n        if (winnners.length > 0) {\r\n            do {\r\n                if (winnners[i] == _player) {\r\n                    uint256 prize = checkPrize(_gameRound, _player);\r\n                    return (true, prize);\r\n                }\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            } while (i < winnners.length);\r\n            return (false, 0);\r\n        } else {\r\n            return (false, 0);\r\n        }\r\n    }\r\n\r\n    /// @notice Check if player game board matches and retrun bool\r\n    /// @dev `drawWinnerOrClaimPrize` will call this internal function\r\n    /// @param _gameRound the round of game id\r\n    /// @param _player player address of this round of game\r\n    function checkWinning(uint256 _gameRound, address _player) internal view returns (bool) {\r\n        uint256 i;\r\n        if (\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[0] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[6] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[18] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[24] == 1\r\n        ) {\r\n            /// @notice BINGO in [1,0,0,0,0]\r\n            /// @notice          [0,1,0,0,0]\r\n            /// @notice          [0,0,1,0,0]\r\n            /// @notice          [0,0,0,1,0]\r\n            /// @notice          [0,0,0,0,1]\r\n            return (true);\r\n        }\r\n\r\n        if (\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[4] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[8] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[16] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[20] == 1\r\n        ) {\r\n            /// @notice BINGO in [0,0,0,0,1]\r\n            /// @notice          [0,0,0,1,0]\r\n            /// @notice          [0,0,1,0,0]\r\n            /// @notice          [0,1,0,0,0]\r\n            /// @notice          [1,0,0,0,0]\r\n            return (true);\r\n        }\r\n        do {\r\n            if (\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[i * 5 + 0] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[i * 5 + 1] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[i * 5 + 2] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[i * 5 + 3] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[i * 5 + 4] == 1\r\n            ) {\r\n                /// @notice BINGO in [1,1,1,1,1] ↓\r\n                /// @notice          [0,0,0,0,0] ↓\r\n                /// @notice          [0,0,0,0,0] ↓\r\n                /// @notice          [0,0,0,0,0] ↓\r\n                /// @notice          [0,0,0,0,0] ↓\r\n                return (true);\r\n            } else if (\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[0 + i] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[5 + i] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[10 + i] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[15 + i] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[20 + i] == 1\r\n            ) {\r\n                /// @notice           → → → → →\r\n                /// @notice BINGO in [1,0,0,0,0]\r\n                /// @notice          [1,0,0,0,0]\r\n                /// @notice          [1,0,0,0,0]\r\n                /// @notice          [1,0,0,0,0]\r\n                /// @notice          [1,0,0,0,0]\r\n                return (true);\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        } while (i < 5);\r\n\r\n        return (false);\r\n    }\r\n\r\n    /// @notice set config for the game, such as join durations, turn durations, bet amount for bingo game, returnBet boolean for if game returns no-winner game, max player numbers in one game\r\n    function setConfig(\r\n        uint256 _joinDuration,\r\n        uint256 _turnDuration,\r\n        uint256 _betAmountForBINGO,\r\n        bool _returnBet,\r\n        uint256 _maxPlayerNum\r\n    ) public {\r\n        if (msg.sender != admin) revert error__notAdmin();\r\n        joinDuration = _joinDuration;\r\n        turnDuration = _turnDuration;\r\n        betAmountForBINGO = _betAmountForBINGO;\r\n        returnBet = _returnBet;\r\n        maxPlayerNum = _maxPlayerNum;\r\n    }\r\n}\r\n"
    },
    "contracts/BingoGame.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.8;\r\n\r\n/// @title Bingo Game Smart Contract\r\n/// @author astro Ge\r\n/// @notice You can use this contract for playing bingo game\r\n\r\nimport \"./Interface/ICER20.sol\";\r\nimport \"hardhat/console.sol\";\r\nerror erorr__entryFee();\r\nerror error__inGameAlready();\r\nerror error__drawsNotStared();\r\nerror error__winnerIsDRAWING();\r\nerror error__gameStarted();\r\nerror error__notInGameOrClaimedRewards();\r\nerror error__notAdmin();\r\nerror error__exceedLimitPlayersInOneGame();\r\nerror error__gameWinnerDrawed();\r\nerror error__gameWinnerNotDrawed();\r\n\r\ncontract Bingo {\r\n    /// @notice This is game stage for each player in each game round\r\n    enum gameStage {\r\n        BETTING,\r\n        DRAWING,\r\n        DARWED\r\n    }\r\n\r\n    /// @notice This is player struct in each game round\r\n    struct player {\r\n        gameStage stage;\r\n        uint256[25] gameBoard;\r\n        /// @notice Matched number will be set as 1 for function to know it matches, 0 means unmatch\r\n        mapping(uint256 => uint256) gameBoardMatchs;\r\n    }\r\n\r\n    struct gameRound {\r\n        /// @notice When one person calls function `drawWinnerOrClaimRewrads`, it will draw the winner of this round\r\n        bool drawing;\r\n        /// @notice If `winnerAnnounced` is true, other players don't have to draw instead of claiming their prize\r\n        bool winnerAnnounced;\r\n        uint256 startTime;\r\n        uint256 bingo;\r\n        /// @notice Support multiple players in a game\r\n        /// @notice If two or more players have their first bingo in the same round, they will share the prize pool\r\n        address[] winner;\r\n        address[] playersArray;\r\n        uint256[24] winningNumders;\r\n        mapping(address => player) players;\r\n    }\r\n\r\n    uint256 public gameRoundNow;\r\n    /// @notice Admin can update the entry fee, join duration, and turn duration\r\n    address public admin;\r\n    /// @notice Games have a minimum join duration before start\r\n    /// @notice `joinDuration` sets to 180 seconds as default to save gas\r\n    uint256 public joinDuration = 180;\r\n    /// @notice Games have a minimum turn duration between draws\r\n    /// @notice `turnDuration` sets to 180 seconds as default to save gas\r\n    uint256 public turnDuration = 180;\r\n    /// @notice Each player pays an ERC20 entry fee, transferred on join\r\n    address public BingoToken;\r\n    /// @notice `betAmountForBINGO` sets to 1 token as default to save gas\r\n    uint256 public betAmountForBINGO = 1000000000000000000;\r\n    /// @notice returnBet sets the contract whether return player entry fee or not\r\n    bool public returnBet;\r\n    /// @notice maxPlayerNum sets the max player numbers in a game, default as 4 due to out of gas problem\r\n    uint256 public maxPlayerNum = 4;\r\n\r\n    /// @notice Support multiple concurrent games\r\n    mapping(uint256 => gameRound) gameRounds;\r\n\r\n    /// @notice Event emit when player create a new game\r\n    event Created(\r\n        address indexed creator,\r\n        uint256 indexed roundCreated,\r\n        uint256 indexed timeCreated\r\n    );\r\n    /// @notice Event emit when player joins a existing game\r\n    event Joined(address indexed player, uint256 indexed roundJoined);\r\n    /// @notice Event emit when a game is drawed\r\n    /// @dev bingoRound == 0: no Bingo; bingoRound > 0: bingo in number of rounds\r\n    event Drawed(\r\n        uint256 indexed gameRound,\r\n        uint256 indexed playersNum,\r\n        uint256[24] winningNumbers,\r\n        uint256 bingoRound\r\n    );\r\n    /// @notice Event emit when a player claimed prize\r\n    event Claimed(address indexed player, uint256 indexed Claimed);\r\n\r\n    modifier onlyAdmin() {\r\n        if (msg.sender != admin) revert error__notAdmin();\r\n        _;\r\n    }\r\n    /// @notice Only allowing one player to draw the winning numbers with time limit\r\n    modifier drawingWinnerCheck(uint256 _gameRound) {\r\n        if (block.timestamp < gameRounds[_gameRound].startTime + joinDuration + turnDuration)\r\n            revert error__drawsNotStared();\r\n        if (gameRounds[_gameRound].drawing) revert error__winnerIsDRAWING();\r\n\r\n        /// @notice Start drawing\r\n        gameRounds[_gameRound].drawing = true;\r\n        _;\r\n        /// @notice Stop drawing\r\n        gameRounds[_gameRound].drawing = false;\r\n    }\r\n\r\n    /// @notice Deploying Bingo Token first before deploying this contract\r\n    constructor(address _bingoTokenAddress) {\r\n        BingoToken = _bingoTokenAddress;\r\n        admin = msg.sender;\r\n    }\r\n\r\n    /// @notice player start a new with game board generated\r\n    function startNewGameWithBet() public {\r\n        /// @notice Send Bingo Token to this contract, and check transaction success\r\n        if (IERC20(BingoToken).transferFrom(msg.sender, address(this), betAmountForBINGO) != true)\r\n            revert erorr__entryFee();\r\n        /// @notice Make a new game round\r\n        unchecked {\r\n            ++gameRoundNow;\r\n        }\r\n        /// @notice Save game round Id into this function\r\n        uint256 gameRoundnow = gameRoundNow;\r\n        /// @notice Save game round start time\r\n        gameRounds[gameRoundnow].startTime = block.timestamp;\r\n        /// @notice Generating player game board for this game round\r\n        playerGenerateGameBoard(msg.sender, gameRoundnow);\r\n        emit Created(msg.sender, gameRoundnow, block.timestamp);\r\n    }\r\n\r\n    /// @notice Players join current game and generate their game board\r\n    /// @param _gameRoundToJoin the round of game id\r\n    /// @dev Worst case of nobody has a bingo for 4 players are about 24356551 gas within 0 - 64 as numbers that this contract generated for bingo game with 24 winning numbers generated\r\n    function joinCurrentGameWithBet(uint256 _gameRoundToJoin) public {\r\n        /// @notice With 2 lines above being said, limit no more than 4 players in a game to limit out of gas problem\r\n        if (gameRounds[_gameRoundToJoin].playersArray.length + 1 > maxPlayerNum)\r\n            revert error__exceedLimitPlayersInOneGame();\r\n        (gameStage stageOfPlayer, uint256 roundStartedTimeWithDuration) = getRoundDetails(\r\n            _gameRoundToJoin,\r\n            msg.sender\r\n        );\r\n        /// @notice Player can join multiple game at the same time, but not in the same round\r\n        if (stageOfPlayer != gameStage.BETTING) revert error__inGameAlready();\r\n        /// @notice Players can not join the game after join duration\r\n        if (block.timestamp > roundStartedTimeWithDuration) revert error__gameStarted();\r\n        /// @notice Send Bingo Token to this contract, and check transaction success\r\n        if (IERC20(BingoToken).transferFrom(msg.sender, address(this), betAmountForBINGO) != true)\r\n            revert erorr__entryFee();\r\n        /// @notice Generating player game board for this game round\r\n        playerGenerateGameBoard(msg.sender, _gameRoundToJoin);\r\n    }\r\n\r\n    /// @notice Players draw winner of this game round or claim prize\r\n    /// @dev if one game is drawed, other players in this round\r\n    /// @param _gameRound the round of game id that player joined\r\n    function drawWinner(uint256 _gameRound) public drawingWinnerCheck(_gameRound) {\r\n        /// @notice Read bet amount to use for this function at beginning to save gas\r\n        /// @notice If winner is announced then distribute the prize to the caller\r\n        /// @dev This only be true when second time this function is called\r\n        if (gameRounds[_gameRound].winnerAnnounced == true) revert error__gameWinnerDrawed();\r\n        /// @notice Draw winner or winners, if two players achieved bingo in the same round, they will split the prize poll\r\n        /// @dev Drawing winner spend unbelievable gas amount, using a automation keeper to call this function could wave gas for player in real cases\r\n        /// @notice Read players's addresses to use for this function at beginning of drawing process to save gas\r\n        address[] memory playersArrays = gameRounds[_gameRound].playersArray;\r\n        /// @notice Init winningNumbers array now for event params\r\n        uint256[24] memory winningNumbers;\r\n        /// @notice if there are more than one player in the game, then drawing start\r\n        if (playersArrays.length > 1) {\r\n            uint256 BingoIndex = 24;\r\n            /// @notice Call `gameGenerateNumber` to generate winning numbers\r\n            /// @dev Will generate 24 winning numbers for players for full experience of Bingo game\r\n            winningNumbers = gameGenerateNumber(_gameRound);\r\n            /// @notice i: i is representing players index in this game round, loop from first player to the last player\r\n            /// @notice j: j is representing players first bingo index in this game round\r\n            /// @dev j: if there is a first bingo in any players game board, we set j + 1 for the loop limit to save gas\r\n            /// @notice k: k is representing players game board number index, loop from 0 - 24\r\n            uint256 i;\r\n            uint256 j;\r\n            uint256 k;\r\n            do {\r\n                j = 0;\r\n                do {\r\n                    k = 0;\r\n                    uint256[25] memory playerGameBoard = getPlayerGameBoard(\r\n                        playersArrays[i],\r\n                        _gameRound\r\n                    );\r\n                    do {\r\n                        /// @notice If winning number and one of the player game board matches, set the players game board matches mapping to be 1\r\n                        if (winningNumbers[j] == playerGameBoard[k]) {\r\n                            gameRounds[_gameRound].players[playersArrays[i]].gameBoardMatchs[\r\n                                k\r\n                            ] = 1;\r\n                        }\r\n                        /// @notice Skip center number\r\n                        if (k == 11) {\r\n                            unchecked {\r\n                                ++k;\r\n                            }\r\n                        }\r\n                        unchecked {\r\n                            ++k;\r\n                        }\r\n                        /// @notice When checking more than 5 numbers, check if this is a bingo or not\r\n                        if (k > 4) {\r\n                            /// @notice If bingo is true\r\n                            if (checkWinning(_gameRound, playersArrays[i])) {\r\n                                /// @notice set j to be bingo round + 1 to let other player check till this round to see if there are more than one winner in this game\r\n                                if (j == BingoIndex - 1) {\r\n                                    gameRounds[_gameRound].winner.push(playersArrays[i]);\r\n                                } else {\r\n                                    /// @notice If new bingo round is less than the first one, clean winner array and save this new winner\r\n                                    gameRounds[_gameRound].winner = new address[](0);\r\n                                    gameRounds[_gameRound].winner.push(playersArrays[i]);\r\n                                }\r\n                                unchecked {\r\n                                    BingoIndex = j + 1;\r\n                                }\r\n                                /// @notice Save bingo round number into contract\r\n                                gameRounds[_gameRound].bingo = j;\r\n                                console.log(\r\n                                    \"First Bingo in round\",\r\n                                    j,\r\n                                    \"for player address\",\r\n                                    playersArrays[i]\r\n                                );\r\n                                break;\r\n                            }\r\n                        }\r\n                    } while (k < 25);\r\n                    unchecked {\r\n                        ++j;\r\n                    }\r\n                } while (j < BingoIndex);\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            } while (i < playersArrays.length);\r\n            i = 0;\r\n            /// @notice Winner wins the pot of entry fees, transferred on win\r\n            do {\r\n                (bool a, uint256 b) = checkWinner(_gameRound, playersArrays[i]);\r\n                if (a) {\r\n                    IERC20(BingoToken).transfer(playersArrays[i], b);\r\n                    gameRounds[_gameRound].players[playersArrays[i]].stage = gameStage.DARWED;\r\n                    emit Claimed(playersArrays[i], b);\r\n                }\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            } while (i < playersArrays.length);\r\n        }\r\n        gameRounds[_gameRound].winnerAnnounced = true;\r\n        emit Drawed(\r\n            _gameRound,\r\n            playersArrays.length,\r\n            winningNumbers,\r\n            gameRounds[_gameRound].bingo\r\n        );\r\n    }\r\n\r\n    /// @notice Players claim prize if retrun bet is true or there is only one player in this game round\r\n    /// @dev Normally player dont need to call this function, in case of draw function error\r\n    /// @dev If return bet is true, player needs to call this function to get the token back\r\n    /// @param _gameRound the round of game id that player joined\r\n    function claimPrize(uint256 _gameRound) public drawingWinnerCheck(_gameRound) {\r\n        /// @notice Cheak if stage of player in this is DRAWING to let them draw or claim\r\n        if (gameRounds[_gameRound].players[msg.sender].stage != gameStage.DRAWING)\r\n            revert error__notInGameOrClaimedRewards();\r\n        /// @notice Read bet amount to use for this function at beginning to save gas\r\n        uint256 betAmount = betAmountForBINGO;\r\n        uint256 prizeToSend;\r\n        /// @notice If winner is announced then distribute the prize to the caller\r\n        /// @dev This only be true when second time this function is called\r\n        if (gameRounds[_gameRound].winnerAnnounced == false) revert error__gameWinnerNotDrawed();\r\n        /// @notice If there is one of more bingo achieved, check the prize and send to the winner\r\n        if (gameRounds[_gameRound].bingo > 0) {\r\n            prizeToSend = checkPrize(_gameRound, msg.sender);\r\n            if (prizeToSend > 0) {\r\n                IERC20(BingoToken).transfer(msg.sender, prizeToSend);\r\n            }\r\n            /// @dev Choosing by admin about sending back players bet fees, becuase house needs token as funds to balance out automation keepers gas spend, I chose not to send back token as house revenue\r\n        } else if (gameRounds[_gameRound].playersArray.length <= 1 || returnBet) {\r\n            /// @notice If there one player in a game refund Bingo Token player bet\r\n            /// @notice If there no bingo achieved, refund Bingo Token player bet\r\n            IERC20(BingoToken).transfer(msg.sender, betAmount);\r\n        }\r\n        gameRounds[_gameRound].players[msg.sender].stage = gameStage.DARWED;\r\n        emit Claimed(msg.sender, prizeToSend);\r\n    }\r\n\r\n    /// @notice Player generating game board when creating or joinning a game\r\n    /// @dev `joinCurrentGameWithBet` & `startNewGameWithBet` will call this internal function\r\n    /// @param _player player's address\r\n    /// @param _gameRound the round of game id\r\n    function playerGenerateGameBoard(address _player, uint256 _gameRound) internal {\r\n        /// @notice Change player's stage of this game round to DRAWING\r\n        gameRounds[_gameRound].players[_player].stage = gameStage.DRAWING;\r\n        /// @notice Save player's address to game round player array\r\n        gameRounds[_gameRound].playersArray.push(_player);\r\n        uint256 i;\r\n        /// @notice Make a memory array for generating game board numbers in this function\r\n        /// @dev Saving more gas compares to directly save numbers into contract each time\r\n        uint256[25] memory array;\r\n        /// @dev Generate random number, but could be replaced by on-chain services provider, such as Chainlink\r\n        bytes32 blockHashPrevious = blockhash(block.number - 1);\r\n        uint256 seed = uint256(blockHashPrevious);\r\n        uint256 randomNumber = uint256(keccak256(abi.encodePacked(seed, msg.sender)));\r\n        /// @dev Use do while and unchecked{} to save gas.\r\n        do {\r\n            /// @notice Check if the random number bigger than 64\r\n            /// @dev The reason why i choose 64 is because 256 will hardly get a bingo and spent a lot of gas without a winner\r\n            /// @dev We could definetly choose 256 if we insist\r\n            randomNumber = (randomNumber >> 6 > 0)\r\n                ? (randomNumber >> 6) % 64\r\n                : (uint256(keccak256(abi.encodePacked(seed, msg.sender, i)))) % 64;\r\n            /// @notice Save random number into memory array\r\n            array[i] = randomNumber;\r\n            /// @notice No need to save the center game borad number\r\n            if (i == 11) {\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        } while (i < 25);\r\n        /// @notice Save generated number into player game board\r\n        gameRounds[_gameRound].players[_player].gameBoard = array;\r\n        /// @notice Set player game board matches array[12] become matched\r\n        gameRounds[_gameRound].players[_player].gameBoardMatchs[12] = 1;\r\n        emit Joined(msg.sender, _gameRound);\r\n    }\r\n\r\n    /// @notice Game generating winning number of this game round\r\n    /// @dev `drawWinnerOrClaimPrize` will call this internal function\r\n    /// @param _gameRound the round of game id\r\n    function gameGenerateNumber(uint256 _gameRound) internal returns (uint256[24] memory) {\r\n        /// @notice Make a memory array for generating game board numbers in this function\r\n        /// @dev Saving more gas compares to directly save numbers into contract each time\r\n        /// @dev Choose 24 winning numbers between 0 - 63 is enough for a bingo to be true, and it is also be able to make player gameboard match all bingos\r\n        /// @dev Worst case of nobody has a bingo for five players are about 28000000 gas within 0 - 64 as numbers that this contract generated for bingo game with 24 winning numbers generated\r\n        /// @dev We could definetly choose more to make every game has a Bingo if we insist\r\n        uint256[24] memory array;\r\n        uint256 i;\r\n        /// @dev Generate random number, but could be replaced by on-chain services provider, such as Chainlink\r\n        bytes32 blockHashPrevious = blockhash(block.number - 1);\r\n        uint256 seed = uint256(blockHashPrevious);\r\n        uint256 randomNumber = uint256(keccak256(abi.encodePacked(seed, msg.sender)));\r\n        /// @dev Use do while and unchecked{} to save gas.\r\n        do {\r\n            /// @notice Check if the random number bigger than 64\r\n            /// @dev The reason why choose 64 is because 256 will hardly get a bingo and spent a lot of gas without a winner\r\n            /// @dev We could definetly choose 256 if we insist\r\n            randomNumber = (randomNumber >> 6 > 0)\r\n                ? (randomNumber >> 6) % 64\r\n                : (uint256(keccak256(abi.encodePacked(seed, msg.sender, i)))) % 64;\r\n            /// @notice Save random number into memory array\r\n            array[i] = randomNumber;\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        } while (i < 24);\r\n        /// @notice Save winning numbers into contract\r\n        gameRounds[_gameRound].winningNumders = array;\r\n        return (array);\r\n    }\r\n\r\n    /// @notice get player stage of this round and timestamp right after join duration ends\r\n    /// @dev `joinCurrentGameWithBet` will call this internal function\r\n    /// @param _gameRound the round of game id\r\n    /// @param _player player address of this round of game\r\n    function getRoundDetails(\r\n        uint256 _gameRound,\r\n        address _player\r\n    ) internal view returns (gameStage, uint256) {\r\n        return (\r\n            gameRounds[_gameRound].players[_player].stage,\r\n            gameRounds[_gameRound].startTime + joinDuration\r\n        );\r\n    }\r\n\r\n    /// @notice Get the Bingo result of this round of game and winning numbers\r\n    /// @param _gameRound the round of game id\r\n    function getRoundBingoResult(\r\n        uint256 _gameRound\r\n    ) public view returns (bool, uint256[24] memory) {\r\n        return (gameRounds[_gameRound].bingo > 0, gameRounds[_gameRound].winningNumders);\r\n    }\r\n\r\n    /// @notice Get player game board numbers in a uint256 array\r\n    /// @param _gameRound the round of game id\r\n    /// @param _player player address of this round of game\r\n    function getPlayerGameBoard(\r\n        address _player,\r\n        uint256 _gameRound\r\n    ) public view returns (uint256[25] memory) {\r\n        return (gameRounds[_gameRound].players[_player].gameBoard);\r\n    }\r\n\r\n    /// @notice Check prize for the player of this game round\r\n    /// @dev `claimPrize` and `checkWinner` will call this internal function\r\n    /// @param _gameRound the round of game id\r\n    /// @param _player player address of this round of game\r\n    function checkPrize(\r\n        uint256 _gameRound,\r\n        address _player\r\n    ) internal view returns (uint256 winningPrize) {\r\n        address[] memory winnners = gameRounds[_gameRound].winner;\r\n        uint256 i;\r\n        uint256 n;\r\n        do {\r\n            if (winnners[i] == _player) {\r\n                unchecked {\r\n                    n++;\r\n                }\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        } while (i < winnners.length);\r\n        /// @notice If there is more than one winnier, n will be equal to 1 and times betAmountForBINGO times numbers of players divided by winners number\r\n        return ((n * (betAmountForBINGO * (gameRounds[_gameRound].playersArray.length))) /\r\n            (winnners.length));\r\n    }\r\n\r\n    /// @notice Check if player is the the winner of this game round, and returns bool with winning prize to claim\r\n    /// @param _gameRound the round of game id\r\n    /// @param _player player address of this round of game\r\n    function checkWinner(uint256 _gameRound, address _player) public view returns (bool, uint256) {\r\n        address[] memory winnners = gameRounds[_gameRound].winner;\r\n        uint256 i;\r\n        if (winnners.length > 0) {\r\n            do {\r\n                if (winnners[i] == _player) {\r\n                    uint256 prize = checkPrize(_gameRound, _player);\r\n                    return (true, prize);\r\n                }\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            } while (i < winnners.length);\r\n            return (false, 0);\r\n        } else {\r\n            return (false, 0);\r\n        }\r\n    }\r\n\r\n    /// @notice Check if player game board matches and retrun bool\r\n    /// @dev `drawWinnerOrClaimPrize` will call this internal function\r\n    /// @param _gameRound the round of game id\r\n    /// @param _player player address of this round of game\r\n    function checkWinning(uint256 _gameRound, address _player) internal view returns (bool) {\r\n        uint256 i;\r\n        if (\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[0] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[6] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[18] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[24] == 1\r\n        ) {\r\n            /// @notice BINGO in [1,0,0,0,0]\r\n            /// @notice          [0,1,0,0,0]\r\n            /// @notice          [0,0,1,0,0]\r\n            /// @notice          [0,0,0,1,0]\r\n            /// @notice          [0,0,0,0,1]\r\n            return (true);\r\n        }\r\n\r\n        if (\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[4] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[8] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[16] == 1 &&\r\n            gameRounds[_gameRound].players[_player].gameBoardMatchs[20] == 1\r\n        ) {\r\n            /// @notice BINGO in [0,0,0,0,1]\r\n            /// @notice          [0,0,0,1,0]\r\n            /// @notice          [0,0,1,0,0]\r\n            /// @notice          [0,1,0,0,0]\r\n            /// @notice          [1,0,0,0,0]\r\n            return (true);\r\n        }\r\n        do {\r\n            if (\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[i * 5 + 0] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[i * 5 + 1] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[i * 5 + 2] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[i * 5 + 3] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[i * 5 + 4] == 1\r\n            ) {\r\n                /// @notice BINGO in [1,1,1,1,1] ↓\r\n                /// @notice          [0,0,0,0,0] ↓\r\n                /// @notice          [0,0,0,0,0] ↓\r\n                /// @notice          [0,0,0,0,0] ↓\r\n                /// @notice          [0,0,0,0,0] ↓\r\n                return (true);\r\n            } else if (\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[0 + i] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[5 + i] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[10 + i] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[15 + i] == 1 &&\r\n                gameRounds[_gameRound].players[_player].gameBoardMatchs[20 + i] == 1\r\n            ) {\r\n                /// @notice           → → → → →\r\n                /// @notice BINGO in [1,0,0,0,0]\r\n                /// @notice          [1,0,0,0,0]\r\n                /// @notice          [1,0,0,0,0]\r\n                /// @notice          [1,0,0,0,0]\r\n                /// @notice          [1,0,0,0,0]\r\n                return (true);\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        } while (i < 5);\r\n\r\n        return (false);\r\n    }\r\n\r\n    /// @notice set config for the game, such as join durations, turn durations, bet amount for bingo game, returnBet boolean for if game returns no-winner game, max player numbers in one game\r\n    function setConfig(\r\n        uint256 _joinDuration,\r\n        uint256 _turnDuration,\r\n        uint256 _betAmountForBINGO,\r\n        bool _returnBet,\r\n        uint256 _maxPlayerNum\r\n    ) public onlyAdmin {\r\n        joinDuration = _joinDuration;\r\n        turnDuration = _turnDuration;\r\n        betAmountForBINGO = _betAmountForBINGO;\r\n        returnBet = _returnBet;\r\n        maxPlayerNum = _maxPlayerNum;\r\n    }\r\n\r\n    /// @dev this function helps people who accidentally transfer ERC20 token to our contract, and also withdraw Bingo Token as revenue\r\n    function withdrawToken(\r\n        address _erc20ContractAddress,\r\n        uint256 _amount,\r\n        address _to\r\n    ) external onlyAdmin {\r\n        IERC20(_erc20ContractAddress).approve(address(this), _amount);\r\n        bool callSuccess = IERC20(_erc20ContractAddress).transferFrom(address(this), _to, _amount);\r\n        require(callSuccess, \"Transfer failed\");\r\n    }\r\n}\r\n"
    },
    "contracts/Interface/ICER20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}